

<!DOCTYPE html>
<html class="writer-html5" lang="en" data-content_root="./">
<head>
  <meta charset="utf-8" /><meta name="viewport" content="width=device-width, initial-scale=1" />

  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Basic Tutorial &mdash; ros_bt_py 0.1.1 documentation</title>
      <link rel="stylesheet" type="text/css" href="_static/pygments.css?v=03e43079" />
      <link rel="stylesheet" type="text/css" href="_static/css/theme.css?v=e59714d7" />

  
    <link rel="shortcut icon" href="_static/ros_bt_py.ico"/>
      <script src="_static/jquery.js?v=5d32c60e"></script>
      <script src="_static/_sphinx_javascript_frameworks_compat.js?v=2cd50e6c"></script>
      <script src="_static/documentation_options.js?v=a58bc63e"></script>
      <script src="_static/doctools.js?v=9bcbadda"></script>
      <script src="_static/sphinx_highlight.js?v=dc90522c"></script>
    <script src="_static/js/theme.js"></script>
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="Advanced Tutorial" href="advanced_tutorial.html" />
    <link rel="prev" title="Tutorials" href="tutorials.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >

          
          
          <a href="index.html" class="icon icon-home">
            ros_bt_py
              <img src="_static/ros_bt_py_128.png" class="logo" alt="Logo"/>
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <ul>
<li class="toctree-l1"><a class="reference internal" href="getting_started.html">Getting Started</a><ul>
<li class="toctree-l2"><a class="reference internal" href="getting_started.html#installation">Installation</a><ul>
<li class="toctree-l3"><a class="reference internal" href="getting_started.html#installing-from-binary-packages">Installing from binary packages</a></li>
<li class="toctree-l3"><a class="reference internal" href="getting_started.html#installing-from-source">Installing from source</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="getting_started.html#running-ros-bt-py">Running ros_bt_py</a><ul>
<li class="toctree-l3"><a class="reference internal" href="getting_started.html#launch-options">Launch Options</a></li>
<li class="toctree-l3"><a class="reference internal" href="getting_started.html#stand-alone-web-interface">Stand-alone Web Interface</a></li>
</ul>
</li>
</ul>
</li>
</ul>
<ul class="current">
<li class="toctree-l1 current"><a class="reference internal" href="tutorials.html">Tutorials</a><ul class="current">
<li class="toctree-l2 current"><a class="current reference internal" href="#">Basic Tutorial</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#starting-up-ros-bt-py">Starting up ros_bt_py</a></li>
<li class="toctree-l3"><a class="reference internal" href="#examining-the-interface">Examining the Interface</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#menu-bars">Menu Bars</a></li>
<li class="toctree-l4"><a class="reference internal" href="#package-loader">Package Loader</a></li>
<li class="toctree-l4"><a class="reference internal" href="#node-list">Node List</a></li>
<li class="toctree-l4"><a class="reference internal" href="#editor-window">Editor Window</a></li>
<li class="toctree-l4"><a class="reference internal" href="#node-menu">Node Menu</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#writing-your-first-bt">Writing your first BT</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#make-sure-the-tree-is-not-currently-running">1. Make sure the Tree is not currently running</a></li>
<li class="toctree-l4"><a class="reference internal" href="#add-a-control-flow-node">2. Add a control flow node</a></li>
<li class="toctree-l4"><a class="reference internal" href="#add-a-leaf-node-to-the-tree">3. Add a leaf node to the tree</a></li>
<li class="toctree-l4"><a class="reference internal" href="#modify-the-constant-node">4. Modify the Constant node</a></li>
<li class="toctree-l4"><a class="reference internal" href="#add-a-second-constant-and-a-processing-step">5. Add a second Constant and a processing step</a></li>
<li class="toctree-l4"><a class="reference internal" href="#connecting-the-data-wirings">6. Connecting the Data Wirings</a></li>
<li class="toctree-l4"><a class="reference internal" href="#run-the-finished-tree">7. Run the finished tree</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#working-with-bt-py">Working with bt_py</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#tree-execution">Tree Execution</a></li>
<li class="toctree-l4"><a class="reference internal" href="#nodes">Nodes</a></li>
<li class="toctree-l4"><a class="reference internal" href="#data-graph">Data Graph</a></li>
<li class="toctree-l4"><a class="reference internal" href="#working-with-larger-trees">Working with larger trees</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#understanding-flow-control">Understanding Flow Control</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#basic-control-flows">Basic Control Flows</a></li>
<li class="toctree-l4"><a class="reference internal" href="#advanced-control-flows">Advanced Control Flows</a></li>
<li class="toctree-l4"><a class="reference internal" href="#regarding-memory">Regarding Memory</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#writing-a-more-complex-bt">Writing a more complex BT</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#adding-a-branching-path">1. Adding a branching path</a></li>
<li class="toctree-l4"><a class="reference internal" href="#introducing-randomized-outputs">2. Introducing randomized Outputs</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#using-subtrees">Using Subtrees</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#subtree-i-o">Subtree I/O</a></li>
<li class="toctree-l4"><a class="reference internal" href="#using-a-subtree-in-our-example-tree">Using a Subtree in our example tree</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#using-ros-interfaces-with-ros-bt-py">Using ROS Interfaces with ros_bt_py</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#building-and-processing-messages">Building and processing messages</a></li>
<li class="toctree-l4"><a class="reference internal" href="#topics">Topics</a></li>
<li class="toctree-l4"><a class="reference internal" href="#services-and-actions">Services and Actions</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="advanced_tutorial.html">Advanced Tutorial</a><ul>
<li class="toctree-l3"><a class="reference internal" href="advanced_tutorial.html#using-optionrefs">Using OptionRefs</a><ul>
<li class="toctree-l4"><a class="reference internal" href="advanced_tutorial.html#defining-optionrefs-in-the-nodeconfig">Defining OptionRefs in the NodeConfig</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="node_creation.html">Creating Nodes</a><ul>
<li class="toctree-l2"><a class="reference internal" href="creating_a_node_class_package.html">Creating a Node Class package</a><ul>
<li class="toctree-l3"><a class="reference internal" href="creating_a_node_class_package.html#package-creation">Package Creation</a></li>
<li class="toctree-l3"><a class="reference internal" href="creating_a_node_class_package.html#example-package">Example Package</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="creating_node_classes.html">Creating Node Classes</a><ul>
<li class="toctree-l3"><a class="reference internal" href="creating_node_classes.html#create-a-new-class">1. Create a new class</a></li>
<li class="toctree-l3"><a class="reference internal" href="creating_node_classes.html#fill-in-the-nodeconfig">2. Fill in the NodeConfig</a></li>
<li class="toctree-l3"><a class="reference internal" href="creating_node_classes.html#implement-the-do-methods">3. Implement the <code class="code docutils literal notranslate"><span class="pre">_do_</span></code> methods</a></li>
<li class="toctree-l3"><a class="reference internal" href="creating_node_classes.html#test-your-node">4. Test your node!</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="testing_node_classes.html">Testing Node Classes</a><ul>
<li class="toctree-l3"><a class="reference internal" href="testing_node_classes.html#creating-a-test-folder-and-unit-test-script">Creating a Test Folder and Unit Test Script</a></li>
<li class="toctree-l3"><a class="reference internal" href="testing_node_classes.html#running-your-unit-tests">Running your Unit Tests</a></li>
<li class="toctree-l3"><a class="reference internal" href="testing_node_classes.html#adding-your-unit-tests-to-cmakelists-txt">Adding your Unit Tests to CMakeLists.txt</a></li>
<li class="toctree-l3"><a class="reference internal" href="testing_node_classes.html#adding-your-unit-tests-to-setup-py">Adding your Unit Tests to setup.py</a></li>
<li class="toctree-l3"><a class="reference internal" href="testing_node_classes.html#running-tests-via-colcon">Running Tests via colcon</a></li>
</ul>
</li>
</ul>
</li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="configuration.html">Configuration &amp; Utilities</a><ul>
<li class="toctree-l2"><a class="reference internal" href="advanced_launch_configuration.html">Advanced Launch Configuration</a><ul>
<li class="toctree-l3"><a class="reference internal" href="advanced_launch_configuration.html#using-custom-node-classes-in-a-project">Using Custom Node Classes in a Project</a></li>
<li class="toctree-l3"><a class="reference internal" href="advanced_launch_configuration.html#other-important-launch-arguments">Other Important Launch Arguments</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="utility_functions.html">Utility Functions</a><ul>
<li class="toctree-l3"><a class="reference internal" href="utility_functions.html#what">What?</a></li>
<li class="toctree-l3"><a class="reference internal" href="utility_functions.html#why">Why?</a></li>
<li class="toctree-l3"><a class="reference internal" href="utility_functions.html#how">How?</a></li>
</ul>
</li>
</ul>
</li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="api.html">API</a><ul>
<li class="toctree-l2"><a class="reference internal" href="api.html#module-ros_bt_py.debug_manager">ros_bt_py.debug_manager module</a><ul>
<li class="toctree-l3"><a class="reference internal" href="api.html#ros_bt_py.debug_manager.DebugManager"><code class="docutils literal notranslate"><span class="pre">DebugManager</span></code></a><ul>
<li class="toctree-l4"><a class="reference internal" href="api.html#ros_bt_py.debug_manager.DebugManager.report_state"><code class="docutils literal notranslate"><span class="pre">DebugManager.report_state()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="api.html#ros_bt_py.debug_manager.DebugManager.report_tick"><code class="docutils literal notranslate"><span class="pre">DebugManager.report_tick()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="api.html#ros_bt_py.debug_manager.DebugManager.set_collect_node_diagnostics"><code class="docutils literal notranslate"><span class="pre">DebugManager.set_collect_node_diagnostics()</span></code></a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="api.html#module-ros_bt_py.exceptions">ros_bt_py.exceptions module</a><ul>
<li class="toctree-l3"><a class="reference internal" href="api.html#ros_bt_py.exceptions.AssignmentException"><code class="docutils literal notranslate"><span class="pre">AssignmentException</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="api.html#ros_bt_py.exceptions.BehaviorTreeException"><code class="docutils literal notranslate"><span class="pre">BehaviorTreeException</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="api.html#ros_bt_py.exceptions.MigrationException"><code class="docutils literal notranslate"><span class="pre">MigrationException</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="api.html#ros_bt_py.exceptions.MissingParentError"><code class="docutils literal notranslate"><span class="pre">MissingParentError</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="api.html#ros_bt_py.exceptions.NodeConfigError"><code class="docutils literal notranslate"><span class="pre">NodeConfigError</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="api.html#ros_bt_py.exceptions.NodeStateError"><code class="docutils literal notranslate"><span class="pre">NodeStateError</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="api.html#ros_bt_py.exceptions.TreeTopologyError"><code class="docutils literal notranslate"><span class="pre">TreeTopologyError</span></code></a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="api.html#ros-bt-py-helpers-module">ros_bt_py.helpers module</a></li>
<li class="toctree-l2"><a class="reference internal" href="api.html#ros-bt-py-node-module">ros_bt_py.node module</a></li>
<li class="toctree-l2"><a class="reference internal" href="api.html#ros-bt-py-node-config-module">ros_bt_py.node_config module</a></li>
<li class="toctree-l2"><a class="reference internal" href="api.html#ros-bt-py-node-data-module">ros_bt_py.node_data module</a></li>
<li class="toctree-l2"><a class="reference internal" href="api.html#module-ros_bt_py.ros_helpers">ros_bt_py.ros_helpers module</a><ul>
<li class="toctree-l3"><a class="reference internal" href="api.html#ros_bt_py.ros_helpers.EnumValue"><code class="docutils literal notranslate"><span class="pre">EnumValue</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="api.html#ros_bt_py.ros_helpers.LoggerLevel"><code class="docutils literal notranslate"><span class="pre">LoggerLevel</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="api.html#ros_bt_py.ros_helpers.get_interface_name"><code class="docutils literal notranslate"><span class="pre">get_interface_name()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="api.html#ros_bt_py.ros_helpers.get_message_constant_fields"><code class="docutils literal notranslate"><span class="pre">get_message_constant_fields()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="api.html#ros_bt_py.ros_helpers.get_message_field_type"><code class="docutils literal notranslate"><span class="pre">get_message_field_type()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="api.html#ros_bt_py.ros_helpers.publish_message_channels"><code class="docutils literal notranslate"><span class="pre">publish_message_channels()</span></code></a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="api.html#ros-bt-py-tree-manager-module">ros_bt_py.tree_manager module</a></li>
</ul>
</li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="index.html">ros_bt_py</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="index.html" class="icon icon-home" aria-label="Home"></a></li>
          <li class="breadcrumb-item"><a href="tutorials.html">Tutorials</a></li>
      <li class="breadcrumb-item active">Basic Tutorial</li>
      <li class="wy-breadcrumbs-aside">
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <section id="basic-tutorial">
<span id="id1"></span><h1>Basic Tutorial<a class="headerlink" href="#basic-tutorial" title="Link to this heading"></a></h1>
<div class="toctree-wrapper compound">
</div>
<section id="starting-up-ros-bt-py">
<h2>Starting up ros_bt_py<a class="headerlink" href="#starting-up-ros-bt-py" title="Link to this heading"></a></h2>
<p>To get started launch the library in a sourced shell by running</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>ros2<span class="w"> </span>launch<span class="w"> </span>ros_bt_py<span class="w"> </span>ros_bt_py.launch.py
</pre></div>
</div>
</section>
<section id="examining-the-interface">
<h2>Examining the Interface<a class="headerlink" href="#examining-the-interface" title="Link to this heading"></a></h2>
<p>Then you can open a browser and go to <a class="reference external" href="http://localhost:8085/index.html">http://localhost:8085/index.html</a> to open the BT Editor which
should look like this:</p>
<img alt="Empty GUI" src="_images/gui_empty.png" />
<p>The interface consists of four major parts: The Top Menu Bar, a Package Loader, the Node List and
the large Editor Window.</p>
<section id="menu-bars">
<h3>Menu Bars<a class="headerlink" href="#menu-bars" title="Link to this heading"></a></h3>
<p>On the top of the GUI there are two menu bars, the Top Bar for general control as well as a Support
Bar below that.
The Top Menu Bar contains (from left to right):</p>
<ul class="simple">
<li><p>An indicator to show that the editor is connected to a behavior tree instance</p></li>
<li><p>Additional settings available by clicking the cog icon
* A toggle to control the transmission of data flow information
* A dropdown menu to select which ROS namespace to monitor (you can run multiple behavior trees in
different namespaces)
* A special config button to change the address of the rosbridge server</p></li>
<li><p>Buttons to control the execution of the currently loaded BT.</p></li>
<li><p>Buttons to load a BT from, or save it to, a ROS package.</p></li>
<li><p>Buttons to upload a BT YAML to the editor or download the YAML of the currently loaded BT</p></li>
</ul>
<p>The Support Bar contains:</p>
<ul class="simple">
<li><p>A Tree selection window to select the displayed tree, especially useful when using Subtrees.</p></li>
<li><p>The Name field, which is not really useful???? TODO: Fix?</p></li>
<li><p>The State Field showing the state of the tree, also more on that later.</p></li>
<li><p>Toggle Buttons for the Data Graph (more on that later) and the GUI itself if you want a
fullscreen view.</p></li>
</ul>
</section>
<section id="package-loader">
<h3>Package Loader<a class="headerlink" href="#package-loader" title="Link to this heading"></a></h3>
<p>The Package Loader can be used to load additional Node Classes for use.
To load a new package enter the qualified path of the Python module that contains them and
click the Load Package button.
The Node Classes in the loaded module should now show up in the Node List.
Using the package loader is recommended for Node Class development, while building trees with custom
nodes loading Node Classes through <a class="reference internal" href="advanced_launch_configuration.html#advanced-launch-config"><span class="std std-ref">an advanced launch config</span></a> is
recommended to save time.</p>
</section>
<section id="node-list">
<h3>Node List<a class="headerlink" href="#node-list" title="Link to this heading"></a></h3>
<p>Below the Package Loader a List of all currently available nodes can be found.
The search window on top of the list can be used to restrict the list of displayed nodes.
The search is applied to the node names as well as the node package name.
By hovering over the question mark a detailed Node Class description can be accessed.
Left-clicking on a Node Class selects it for insertion into the BT through the Node Menu.
The node can also be dragged into the Editor Window to directly place it into the BT.</p>
</section>
<section id="editor-window">
<h3>Editor Window<a class="headerlink" href="#editor-window" title="Link to this heading"></a></h3>
<p>The editor canvas shows the currently loaded BT.
While running a tree the editor always shows the state of the tree nodes and can be used for
debugging.
While editing the nodes in the canvas can be dragged around and rearranged freely.</p>
</section>
<section id="node-menu">
<h3>Node Menu<a class="headerlink" href="#node-menu" title="Link to this heading"></a></h3>
<img alt="GUI with active Node Menu" src="_images/gui_node_menu.png" />
<p>When a node in the tree is selected the Node Menu for that node appears.
Here the node itself can be configured or deleted and both the Node Options as well as its Inputs
and Outputs are shown.
When selecting a node during execution the current In- and Outputs can be seen through the Node
Menu.
While interacting with Edges they can also be deleted in the Node Menu.</p>
</section>
</section>
<section id="writing-your-first-bt">
<h2>Writing your first BT<a class="headerlink" href="#writing-your-first-bt" title="Link to this heading"></a></h2>
<p>Before we get into the gritty details of BTs let’s write a first, very basic, tree.
If you want to learn about the details first you can also come back to this section later.</p>
<section id="make-sure-the-tree-is-not-currently-running">
<h3>1. Make sure the Tree is not currently running<a class="headerlink" href="#make-sure-the-tree-is-not-currently-running" title="Link to this heading"></a></h3>
<p>To compose a BT, the tree must not currently be in the RUNNING state.
It is easiest to ensure this by clicking the Shutdown button on the top.</p>
<ol class="arabic simple">
<li><p>Click “Shutdown” once and make sure the State Field shows “EDITABLE”</p></li>
</ol>
<img alt="Empty GUI in EDITABLE State" src="_images/first_tree_0.png" />
</section>
<section id="add-a-control-flow-node">
<h3>2. Add a control flow node<a class="headerlink" href="#add-a-control-flow-node" title="Link to this heading"></a></h3>
<p>To start building the BT, you will have to add nodes from the Node List on the left.
It is common to start by adding a Sequence or Fallback node as the root of the BT.</p>
<ol class="arabic simple">
<li><p>Type “sequence” into the search box and click the Sequence node.</p></li>
<li><p>Customize the node’s name by setting it to “HelloSequence”.</p></li>
<li><p>Add it to the BT by clicking the “Add to Tree” button.</p></li>
</ol>
<img alt="GUI with a Sequence Node" src="_images/first_tree_1.png" />
</section>
<section id="add-a-leaf-node-to-the-tree">
<h3>3. Add a leaf node to the tree<a class="headerlink" href="#add-a-leaf-node-to-the-tree" title="Link to this heading"></a></h3>
<p>Now we add leaf nodes to the Sequence to actually make the tree do something</p>
<ol class="arabic simple">
<li><p>Type “const” into the Search Box.</p></li>
<li><p>Drag Constant from the node list and drag it into the dark rectangle below the “HelloSequence”
node.</p></li>
</ol>
<img alt="GUI with Sequence while Constant is added" src="_images/first_tree_2.png" />
</section>
<section id="modify-the-constant-node">
<h3>4. Modify the Constant node<a class="headerlink" href="#modify-the-constant-node" title="Link to this heading"></a></h3>
<p>After adding the node to the tree it needs to be adjusted to to what we want it to.</p>
<ol class="arabic simple">
<li><p>Click on the Constant node in the canvas that was just added.</p></li>
<li><p>Change the Name to “Constant_1”.</p></li>
<li><p>Change the constant_type to “str” (this will automatically be expanded to “builtin.str”).</p></li>
<li><p>Change the constant_value to “hello”.</p></li>
<li><p>Press “Update Node” to commit the changes.</p></li>
<li><p>The canvas and properties will be updated.</p></li>
</ol>
<img alt="Modifying the Constant Node" src="_images/first_tree_3.png" />
</section>
<section id="add-a-second-constant-and-a-processing-step">
<h3>5. Add a second Constant and a processing step<a class="headerlink" href="#add-a-second-constant-and-a-processing-step" title="Link to this heading"></a></h3>
<p>One Constant is nice, but it can’t do a lot by itself.</p>
<p>First we add another Constant node:</p>
<ol class="arabic simple">
<li><p>Add another constant node by dragging it to the right of the first one.</p></li>
<li><p>Change its type to string and set the name value to “World”.</p></li>
<li><p>Search for “Concat” in the Search Box and select StringConcatenation by dragging it to the
right of the constants.</p></li>
</ol>
</section>
<section id="connecting-the-data-wirings">
<h3>6. Connecting the Data Wirings<a class="headerlink" href="#connecting-the-data-wirings" title="Link to this heading"></a></h3>
<p>Inputs and Outputs of all nodes in the tree are marked as gray squares adjacent to the nodes in
the Editor Window.
When hovering over the little dot on the Constant Nodes you should see the output type.
Data Wirings are created by simply clicking and dragging from an Input to an Output of the same
type or vice versa.
Compatible Inputs or Outputs are highlighted while dragging, as shown in the picture below.</p>
<ol class="arabic simple">
<li><p>Connect the Outputs of the Constants to the processing node.</p></li>
</ol>
<img alt="Connecting the Node Wirings" src="_images/first_tree_4.png" />
</section>
<section id="run-the-finished-tree">
<h3>7. Run the finished tree<a class="headerlink" href="#run-the-finished-tree" title="Link to this heading"></a></h3>
<p>After creating a tree, we need to run it to verify our work.
The tree is usable as it is right now.
But for the purposes of this tutorial,
we will add an additional node to make the result visible in the GUI.</p>
<ol class="arabic simple">
<li><p>Add an IOOutputOption node right of the Concatenation and change its type to str.</p></li>
<li><p>Connect its input with the Concatenation output.</p></li>
<li><p>In the Menu Bar, click on the cog icon and activate the Transmission of data flow information.
This sends data from the tree execution to be visualized in the GUI for debugging.</p></li>
<li><p>Now, run the Tree by pressing “Tick Until Result”.</p></li>
<li><p>Make sure the State Field is displaying “IDLE”, once the execution is done.</p></li>
<li><p>Click on the edge between “StringConcatenation” and “IOOutputOption”.
When the tree is finished we should see the value of the transmitted string being “HelloWorld”.</p></li>
<li><p>A successful run of the tree is indicated by the State Field displaying “IDLE”.</p></li>
</ol>
<img alt="StringConcatenation in the finished tree" src="_images/first_tree_5.png" />
</section>
</section>
<section id="working-with-bt-py">
<h2>Working with bt_py<a class="headerlink" href="#working-with-bt-py" title="Link to this heading"></a></h2>
<p>While working with bt_py, it is important to understand both the tree structure created by the
arrangements of different nodes and the Data Graph used to share information between the
nodes as well as the control of the tree in general.
This section will give an overview of the processing of a BT, the Node Class Types that are
available, how to use them effectively, and all you need to know about the Data Graph.</p>
<section id="tree-execution">
<h3>Tree Execution<a class="headerlink" href="#tree-execution" title="Link to this heading"></a></h3>
<p>Before we talk about the building blocks of a BT in more detail, a short introduction to the actual
tree execution is needed to understand the effect of e.g. different Flow Control Node Classes in the
next sections.</p>
<section id="ticking">
<h4>Ticking<a class="headerlink" href="#ticking" title="Link to this heading"></a></h4>
<p>Traversal through the tree is done by “ticking” the tree.
On Tick, the node that is currently next in line will receive a tick command and execute its internal
“do_tick” method.
This can lead to a multitude of results depending on the Node Class of the ticked node.
In a standard configuration bt_py is trying to tick at a rate of 10 Hz.</p>
</section>
<section id="tree-states">
<h4>Tree States<a class="headerlink" href="#tree-states" title="Link to this heading"></a></h4>
<p>To check the health of your tree and determine your next steps e.g. on a successful run of the tree
you need to understand the different Tree States as shown in the State Field</p>
<ul class="simple">
<li><p><strong>EDITABLE:</strong>
The tree is currently not running and changes can be made in the canvas.</p></li>
<li><p><strong>RUNNING:</strong>
The tree is currently running and no changes can be made.
Everything is great.</p></li>
<li><p><strong>IDLE:</strong>
The tree reached a terminal state, but you will have to call Shutdown before you are able to edit
it.</p></li>
<li><p><strong>ERROR:</strong>
The tree reached an error state while executing.
Something went wrong - find the bug.</p></li>
</ul>
</section>
<section id="execution-modes">
<h4>Execution modes<a class="headerlink" href="#execution-modes" title="Link to this heading"></a></h4>
<p>When running a tree the Top Bar gives you multiple execution modes to choose from:</p>
<ul class="simple">
<li><p><strong>Tick Once:</strong>
Run exactly one single Tick through the tree.
Especially useful when trying to debug a faulty tree.</p></li>
<li><p><strong>Tick Periodically:</strong>
Run Ticks until Shutdown is called.
After a successful run the tree will reset and start again instead of going into the IDLE state.</p></li>
<li><p><strong>Tick Until Result:</strong>
Run Ticks until Shutdown is called or the tree transitions into the IDLE state.</p></li>
<li><p><strong>Stop:</strong>
TODO: Does this do something?</p></li>
<li><p><strong>Reset:</strong>
Reset the tree.
This will not change the Tree State and should only be called while IDLE.
Data in the tree as well as the Node States of the tree nodes will be reset.</p></li>
<li><p><strong>Shutdown:</strong>
Halt and shut down the tree completely.
This is your get out of jail free card.
Use this to get into EDITABLE to edit your tree from any other Tree State.</p></li>
</ul>
</section>
</section>
<section id="nodes">
<h3>Nodes<a class="headerlink" href="#nodes" title="Link to this heading"></a></h3>
<p>Nodes are the backbone of each tree, creating the control flow in the BT as well as actually doing
something.
Every Node belongs to a Node Class, determining what the Node will do when it gets ticked.
Additionally, each node is assigned a Node State, representing its current condition and defining the
behavior the Node will display when ticked.</p>
<section id="node-states">
<h4>Node States<a class="headerlink" href="#node-states" title="Link to this heading"></a></h4>
<p>Node States are shown by a color coded frame which can be used to visually debug a tree during
runtime.
Additionally, Node States can affect the flow of the tree and which nodes are ticked through Flow
Control Nodes.</p>
<ul class="simple">
<li><p><strong>UNINITIALIZED:</strong>
An uninitialized node is a node in a tree that has not been executed.
The node will have a gray frame while being in this state.
When ticking any node in a tree all uninitialized nodes will transition to IDLE.</p></li>
<li><p><strong>IDLE:</strong>
An idle node has not yet been ticked, but is ready to be ticked.
The node will have a light blue frame while being in this state.
Calling Reset will reset all nodes in the tree to IDLE.</p></li>
<li><p><strong>SUCCEEDED:</strong>
A succeeded node has reached its terminal state and its action was successful.
The node will have a light green frame while being in this state.</p></li>
<li><p><strong>FAILED:</strong>
A failed node has reached its terminal state and its action failed.
The node will have a light red frame while being in this state.
Failing does not mean something went wrong!</p></li>
<li><p><strong>BROKEN:</strong>
A broken node has encountered an error while executing and will set the Tree State to ERROR.
The node will have a dark red frame while being in this state.
Broken nodes mean something is wrong - most probably in your node implementation.</p></li>
<li><p><strong>SHUTDOWN:</strong>
A shut down node means Shutdown was called on the whole tree and all nodes should be in that
state.
The node will have a dark red frame, similar to the BROKEN state.</p></li>
</ul>
</section>
<section id="node-class-types">
<h4>Node Class Types<a class="headerlink" href="#node-class-types" title="Link to this heading"></a></h4>
<p>Node Classes are grouped into three Types: Flow Control, Decorator and Leaf nodes.
Types are defined by their allowed number of Child Nodes (Nodes that are below the respective node
in the tree) which underlines their intended usage.</p>
<ul class="simple">
<li><p>Flow Control Nodes are allowed to have an unlimited amount of Child Nodes.
They are used to control the general execution of the tree and create the structure of the tree.</p></li>
<li><p>Decorator Nodes are allowed to have exactly one Child Node.
They are used to apply conditions to this single child, such as ignoring its terminal state or
repeating the execution.</p></li>
<li><p>Leaf Nodes are the nodes that actually do something, such as providing or processing data.</p></li>
</ul>
</section>
</section>
<section id="data-graph">
<h3>Data Graph<a class="headerlink" href="#data-graph" title="Link to this heading"></a></h3>
<p>To distribute data between nodes, bt_py uses a Data Graph instead of a blackboard implementation as
it is used in bt_cpp and other implementations.</p>
<p>This means that data needs to be explicitly wired between Inputs and Outputs of the individual
nodes, but you don’t need to worry about which entries are in your blackboard at a certain time.</p>
<p>To wire Data, draw a graph edge from an input to an output or vice versa.
While both Inputs and Outputs can have multiple connections at the same time, allowing for complex
information flow in the tree, Inputs need to have at least one connection for the tree to start
execution, as ticking a node without a set Input would lead to undefined behavior.
Outputs do not need to have a connection and can be left empty.</p>
<p>Output values are only sent through the Data Graph when the node they are attached to is ticked, so
make sure that your control flow takes that into account.</p>
<p>Input and Output data types need to match when creating an edge, which can lead to problems when
changing Node Classes for already connected trees.
To ensure easy tree manipulation delete edges from nodes before changing the node or the Node Class
implementation.</p>
</section>
<section id="working-with-larger-trees">
<h3>Working with larger trees<a class="headerlink" href="#working-with-larger-trees" title="Link to this heading"></a></h3>
<p>As soon as there is more than one Node in the BT, Nodes can be moved via drag &amp; drop.
While dragging a Node, translucent drop targets appear at the positions it can be moved to.
The canvas can be scrolled freely, either by clicking and dragging on the background or by moving
the cursor close to one of its corners while dragging a Node or Wiring.</p>
</section>
</section>
<section id="understanding-flow-control">
<h2>Understanding Flow Control<a class="headerlink" href="#understanding-flow-control" title="Link to this heading"></a></h2>
<p>Flow Control Nodes are integral to effective BT design which is why we will explain them in more
detail.
For understanding Leaf and Decorator Node Classes please refer to the docs.</p>
<section id="basic-control-flows">
<h3>Basic Control Flows<a class="headerlink" href="#basic-control-flows" title="Link to this heading"></a></h3>
<p>The most basic Control Flow Nodes you will use the most are Sequences and Fallback nodes.</p>
<p><strong>Sequences</strong> are ticked until all their Child Nodes returns success, making them suitable for
linear action sequences you want the tree to trigger, such as getting a goal and driving to the goal
with your robot.
They will return FAILED as soon as one child fails.</p>
<p><strong>Fallbacks</strong> are ticked until one(!) of their Child Nodes returns success, making them suitable for
basic branching of different behaviors, such as deciding on which action to take first when multiple
actions might be suitable in the current situation.
They will only return FAILED if all children fail.</p>
</section>
<section id="advanced-control-flows">
<h3>Advanced Control Flows<a class="headerlink" href="#advanced-control-flows" title="Link to this heading"></a></h3>
<p>While Fallbacks and Sequences are great for designing a BT, sometimes more complex Flow Control is
needed.</p>
<p><strong>Name Switches</strong> are used for targeted selection of action paths, ticking only the Child Node whose
name matches the Input of the Name Switch and will return the terminal state of that child.</p>
<p><strong>Parallel</strong> nodes are used to trigger multiple Child Nodes at the same time, enabling parallel
behaviors.
Child Nodes are ticked until they reach a terminal state and will not be ticked again until all
children return a result.
The return value of the Parallel node is determined by the amount of successes needed which can be
configured in the Node Menu.
While the amount of allowed failures of a bare Parallel node is implicitly given by the amount of
successes needed a <strong>ParallelFailureTolerance</strong> allows for more flexibility by explicitly defining
the amount of allowed failures.</p>
</section>
<section id="regarding-memory">
<h3>Regarding Memory<a class="headerlink" href="#regarding-memory" title="Link to this heading"></a></h3>
<p>As you might have noticed by now, both Fallback and Sequence Node Classes are also available in two
versions, one basic and one memory version.
While the behavior of those nodes is the same when all nodes in the BT return their results on their
first tick, it is vastly different when looking into longer running behaviors - such as moving your
robot to a goal pose/point.</p>
<p>The basic implementations of the Node Classes will <em>untick</em> all their Child Nodes as soon as one
child returns RUNNING.
This is awesome when trying to create a reactive behavior, but will lead to weird and unwanted
effects if we actually want to give the system the time to finish a behavior e.g. a movement.</p>
<p>To avoid those effects, such as the longer running behavior to be triggered multiple times, both
<strong>Memory Sequence</strong> and <strong>MemoryFallback</strong> nodes can be used.
They will remember the state of their Child Nodes when being ticked again after a node returned
RUNNING and in turn continue ticking that node until it reaches a terminal state.</p>
<p>In general, you will want to mostly use the memory version of the basic Flow Control Node Classes
when writing BTs for robotic applications and only use the basic versions when you explicitly want
to display reactive behaviors.</p>
</section>
</section>
<section id="writing-a-more-complex-bt">
<h2>Writing a more complex BT<a class="headerlink" href="#writing-a-more-complex-bt" title="Link to this heading"></a></h2>
<p>Using the knowledge we gained about more complex Control Flows, we now want to modify our tree that
we created earlier to outputs either “HelloWorld” or “HelloRobot” randomly instead of a boring
“HelloWorld”.</p>
<p>Starting from our basic tree, we need to introduce a branching path through the tree where one path
sets the Input “b” of the “StringConcatenation” to “Hello” and the other sets it to “World”.</p>
<section id="adding-a-branching-path">
<h3>1. Adding a branching path<a class="headerlink" href="#adding-a-branching-path" title="Link to this heading"></a></h3>
<p>Looking at the Flow Control Nodes both a Fallback as well as a Name Switch Node seem feasible, but
for now we choose to use a Fallback as it is the more often used node.
Additionally we add a third Constant “Constant_3” containing the string “Robot”.</p>
<ol class="arabic simple">
<li><p>Drag and Drop a Fallback Node before the StringConcatenation node.</p></li>
<li><p>Drag the Constant_2 node below that Fallback node.</p></li>
<li><p>Drag and Drop an additional Constant node to the right of the Constant_2 and adjust the Constant
type and value</p></li>
<li><p>Connect the output of Constant_3 with the second input of the Concatenation</p></li>
</ol>
<img alt="Fallback added to the tree" src="_images/second_tree_0.png" />
<p>If you run the tree you will observe that the output is always the same, as we did not yet introduce
a way for the first child of the Fallback to fail, creating a situation where the first child will
always succeed and the second child to never be ticked.</p>
</section>
<section id="introducing-randomized-outputs">
<h3>2. Introducing randomized Outputs<a class="headerlink" href="#introducing-randomized-outputs" title="Link to this heading"></a></h3>
<p>Next we want to introduce the random output - Luckily bt_py has a native <strong>RandomInt</strong> Node Class
allowing for easy introduction of a random variable as well as a <strong>CompareConstant</strong> Node Class for
checking our number.</p>
<p>Before adding the node let’s first think about where to do the random number generation and the
tree flow we want to generate.
Just adding the nodes directly under the Fallback will result in an Error state - the RandomInt node
will succeed, letting the Fallback succeed and the StringConcatenation node being ticked with one
unset input!
Clearly the random number check needs to happen in its own Sequence and one of the Constants needs
to be ticked if the check succeeds.
So let’s introduce a Sequence that takes care of this.</p>
<ol class="arabic simple">
<li><p>Drag and Drop a Sequence node below the Fallback left of Constant_2.</p></li>
<li><p>Drag and Drop a RandomInt node and a CompareConstant node below the sequence.
Also Drag the Constant_2 node to the right of them.</p></li>
<li><p>Adjust the <em>max</em> Option in the Node Menu of the RandomInt node to 1 - this will make the node
generate either 0 or 1.</p></li>
<li><p>Check the expected type and value of the CompareConstant node to make sure it will compare an int
to either 0 or 1 - your choice.</p></li>
<li><p>Don’t forget to connect the output of RandomInt with CompareConstant</p></li>
</ol>
<img alt="Added random element" src="_images/second_tree_1.png" />
<p>When running the tree through “TickUntilResult” multiple times and examining the Node Data you will
see that only Constant_2 or Constant_3 is ticked, depending on the generated number.</p>
<p>Randomizing the number at the beginning of the tree does work as well, but trying to keep
information locally helps with making the tree more understandable!</p>
</section>
</section>
<section id="using-subtrees">
<h2>Using Subtrees<a class="headerlink" href="#using-subtrees" title="Link to this heading"></a></h2>
<p>When creating large trees both Data Wiring as well as Tree Structure can quickly get unwieldy.
Additionally, you should try to reuse behaviors as much as possible - no need to create the same tree
section multiple times.</p>
<p>To solve those problems, bt_py provides Subtrees as a way to reduce redundancy and make it possible
to quickly insert complex behaviors in multiple sections of one large tree while keeping the tree
itself well structured.</p>
<p>Inside the top level tree, the Subtree is represented as a single node of the Subtree Node Class.
To load a specific tree you will need to provide the path to the tree inside the Subtree Node
Options.
Note that the path can either be an absolute path, in which case you should lead with <cite>file://</cite> as
well as a path relative to a ROS 2 package, in which case you should lead with <cite>package://</cite>.</p>
<section id="subtree-i-o">
<h3>Subtree I/O<a class="headerlink" href="#subtree-i-o" title="Link to this heading"></a></h3>
<p>While regular Node Classes usually have predefined Inputs/Outputs (except the ROS Interface Node
Classes we will discuss shortly), Subtree nodes need to generate them automatically from the actual
tree definition.</p>
<p>You can define Inputs/Outputs <em>implicitly</em> or <em>explicitly</em>.</p>
<p><em>Implicit</em> definition is the one exception to the rule of unconnected Inputs as it requires you to
leave the Inputs you want to set from outside the Subtree to be empty.
When unchecking the “use_io_nodes” Option in the Subtree Node Menu, unconnected In- and Outputs will
be set to the Subtree In-/Outputs respectively.
<strong>This might cause the BT that is used as a Subtree not to be executable as a standalone tree,
making them hard to verify!</strong></p>
<p><em>Explicit</em> definition makes use of <strong>IOInput</strong> and <strong>IOOutput</strong> Node Classes as well as their
<strong>Option</strong> versions.
These Node Classes have a default value for the Subtree In-/Output, either as an Option or an
Input, allowing for standalone execution and testing.</p>
</section>
<section id="using-a-subtree-in-our-example-tree">
<h3>Using a Subtree in our example tree<a class="headerlink" href="#using-a-subtree-in-our-example-tree" title="Link to this heading"></a></h3>
<p>Let’s say we want to use our randomized string inside a larger tree, where we define the first part
of the tree. But we also want to be able to still execute our “HelloWorld/Robot” example by itself!</p>
<section id="define-inputs-and-outputs">
<h4>1. Define Inputs and Outputs<a class="headerlink" href="#define-inputs-and-outputs" title="Link to this heading"></a></h4>
<p>Using what we learned before, we should utilize the tree as a Subtree, while explicitly defining
tree Inputs and Outputs to keep the tree executable as a standalone tree.</p>
<ol class="arabic simple">
<li><p>Drag and Drop an IOInputOption to the start of the main tree sequence.
There should already be an IOOutputOption node at the end of the sequence from earlier.</p></li>
<li><p>Adjust the Data Types and default values. The default value of the Input should be “Hello”,
the one of the Output is not important as we always set an input.</p></li>
<li><p>Connect the Data Graph and delete the Constant_1 node - it has been substituted by the
IOOutputOption.</p></li>
<li><p>Test the tree. The Output of the IOOutputOption node should be the same as before.</p></li>
</ol>
<img alt="Added IO Nodes" src="_images/third_tree_0.png" />
</section>
<section id="utilize-the-tree-as-a-subtree">
<h4>2. Utilize the tree as a Subtree<a class="headerlink" href="#utilize-the-tree-as-a-subtree" title="Link to this heading"></a></h4>
<p>Now we are ready to use the tree as a Subtree where we manipulate the first part of our output
string.</p>
<ol class="arabic simple">
<li><p>After saving our first tree (let’s call it “subtree.yaml”) open a blank tree by clicking “New”.</p></li>
<li><p>Create a new Sequence with a Constant and a Subtree.</p></li>
<li><p>Load the Subtree we just saved by adjusting the path Option of the Subtree node.
Use <cite>file:///path/to/dir/subtree.yaml</cite>.</p></li>
<li><p>Adjust the Constant to output “Goodbye” and connect the In-/Outputs.</p></li>
<li><p>Verify the Output of the Subtree, it should read “GoodbyeWorld” or “GoodbyeRobot”, depending on
what was rolled in the Subtree.
To see the result, you might use an IOOutputOption in a similar way as before.</p></li>
</ol>
<img alt="Used as Subtree" src="_images/third_tree_1.png" />
</section>
</section>
</section>
<section id="using-ros-interfaces-with-ros-bt-py">
<h2>Using ROS Interfaces with ros_bt_py<a class="headerlink" href="#using-ros-interfaces-with-ros-bt-py" title="Link to this heading"></a></h2>
<p>One of the main reasons for using ros_bt_py is the seamless integration with ROS 2, providing
interfacing with Topics, Services and Actions as well as standard Node Classes for message handling.
All interfaces defined in your sourced workspace are available through a type completion in all
basic bt_py nodes to make the usage even easier and more robust!</p>
<section id="building-and-processing-messages">
<h3>Building and processing messages<a class="headerlink" href="#building-and-processing-messages" title="Link to this heading"></a></h3>
<p>ROS 2 interfaces are often much more complex than the basic data types we used for our examples,
containing multiple data fields which in turn can be complex message types by themselves.
To interface with these messages multiple standard Node Classes are available in ros_bt_py:</p>
<ul class="simple">
<li><p><strong>MessageToFields</strong> is a Node Class that outputs all fields of a message that is provided as an
Input.</p></li>
<li><p><strong>FieldsToMessage</strong> does the inverse, creating a message from all its fields</p></li>
<li><p>TODO: DictToMessage is not working rn?</p></li>
<li><p><strong>GetAttr</strong> and <strong>SetAttr</strong> can be used to modify targeted fields in a message without needing
decomposition and recomposition.</p></li>
</ul>
</section>
<section id="topics">
<h3>Topics<a class="headerlink" href="#topics" title="Link to this heading"></a></h3>
<p>Both Subscriber and Publisher Node Classes are available to use.
They use ROS 2 message definitions as their Inputs and Outputs.</p>
</section>
<section id="services-and-actions">
<h3>Services and Actions<a class="headerlink" href="#services-and-actions" title="Link to this heading"></a></h3>
<p>While topic interaction is nice, the main ways you should interact with your robotic system through
bt_py are Services and Actions.
When working with Services and Actions in the past, we realized that composing Action Goals or
Service Requests and decomposing Action Results/Service Responses needed large amounts of nodes in
each tree.
This is why both the <strong>Service</strong> as well as the <strong>Action</strong> Node Classes provide the fields of their
Goals/Requests as well as Results/Responses directly in the tree, reducing the need for
MessageToFields or FieldsToMessage contructions.</p>
<p>When editing the Service/Action types inside the Node Menu you will realize, that all other fields
(Goals/Feedbacks/Results/Requests/Responses) are completed automatically.</p>
<p>As soon as the respective node is ticked it will call the Action or Service in question and return
RUNNING until a Result/Response arrives in which case the node returns SUCCEEDED.
If the Action/Service call fails, the node will return FAILED.</p>
<p>When working with Actions and Services remember to use Memory Flow Control Node Classes as they take
more than one tick to reach terminal state!</p>
<p>You will still need to process your results tho, as most of the time a successful service call does
not mean the service did what you want it to do.
To avoid this bt_py also provides abstract Services and Actions allowing for quick and easy
implementation and in-node result processing.
To learn more about writing your own nodes see <a class="reference internal" href="creating_node_classes.html#creating-nodes"><span class="std std-ref">Creating Node Classes</span></a>.</p>
</section>
</section>
</section>


           </div>
          </div>
          <footer><div class="rst-footer-buttons" role="navigation" aria-label="Footer">
        <a href="tutorials.html" class="btn btn-neutral float-left" title="Tutorials" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left" aria-hidden="true"></span> Previous</a>
        <a href="advanced_tutorial.html" class="btn btn-neutral float-right" title="Advanced Tutorial" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right" aria-hidden="true"></span></a>
    </div>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2025, FZI Forschungszentrum Informatik.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>